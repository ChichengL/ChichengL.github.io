## 基础知识

## 面试题

### TCP 与 UDP 的区别

| 特性     | TCP                                       | UDP                               | QUIC (基于 UDP)                         |
| -------- | ----------------------------------------- | --------------------------------- | --------------------------------------- |
| 可靠性   | ✅ 可靠传输（丢包重传、顺序保证、无重复） | ❌ 不可靠（可能丢包、乱序、重复） | ✅ 可靠（自己实现 ACK、重传、乱序处理） |
| 连接建立 | 三次握手，RTT 开销高                      | 无连接，零 RTT                    | 内建 0-RTT 握手（和 TLS 1.3 一起）      |
| 延迟     | 较高（握手 + 队头阻塞）                   | 很低（无握手，直接发）            | 很低（无内核队头阻塞，支持多路复用）    |
| 安全性   | 需要配合 TLS/SSL 实现                     | 无                                | 内建 TLS 1.3，加密默认启用              |
| 拥塞控制 | 内建（但升级慢，依赖内核）                | ❌ 无                             | ✅ 自己实现，可快速迭代                 |
| 应用场景 | HTTP/1.1、HTTP/2、邮件、文件传输等        | DNS、语音/视频通话、游戏、直播    | HTTP/3、CDN、移动网络加速               |
| 典型问题 | 队头阻塞（一个包丢了，后面全卡住）        | 需要应用层自己造“可靠机制”        | 解决队头阻塞，多路复用独立传输          |

### TCP 建立断开连接的过程

三次握手

1. 客户端发 SYN（seq=x）→ 服务端：“我能发”；
2. 服务端发 SYN+ACK（seq=y，ack=x+1）→ 客户端：“我能收也能发”；
3. 客户端发 ACK（ack=y+1）→ 服务端：“我知道你能收”；

四次挥手

1. 客户端发 FIN（seq=u）→ 服务端：“我要断开了”；
2. 服务端发 ACK（ack=u+1）→ 客户端：“我知道你要断开”；
3. 服务端发 FIN（seq=v）→ 客户端：“我也断开了”；
4. 客户端发 ACK（ack=v+1）→ 服务端：“我知道你也断开了”；

```mermaid
sequenceDiagram
    participant A as 主动关闭方
    participant B as 被动关闭方

    A->>B: FIN (我不发数据了)
    B->>A: ACK (收到你的FIN)
    B->>A: FIN (我也不发数据了)
    A->>B: ACK (收到你的FIN，连接关闭)
```

四次挥手特定情况下能变为 3 次挥手

1. 合并第二步 ACK 和第三步 FIN
   被动关闭方在收到 FIN 后，直接回复 带 ACK 的 FIN（FIN+ACK）。
   主动关闭方收到后再发最后一个 ACK。
   整体就成了 三次挥手。
   适用场景：服务端（被动关闭方）正好没有数据发送

```mermaid
sequenceDiagram
    participant A as 主动关闭方
    participant B as 被动关闭方

    A->>B: FIN (我不发数据了)
    B->>A: FIN+ACK (确认你的FIN，并告诉你我也不发了)
    A->>B: ACK (收到你的FIN，连接关闭)

```

但是如果要干掉第一个或者第二个 ACK 是不可行的

如果省略第一个 ack

- 如果不立刻 ACK，主动关闭方就不知道自己的 FIN 是否被收到，会以为丢包，触发 重传 FIN。
- 这会导致双方的 状态机不同步（客户端以为自己还没关闭发送端，服务端其实已经准备关闭）。

```mermaid
sequenceDiagram
    participant C as 客户端(主动关闭)
    participant S as 服务端(被动关闭)

    C->>S: FIN
    Note right of S: 服务端收到FIN但沉默

    Note left of C: 客户端等待ACK, 超时重传FIN
    C-->>S: FIN (重传)
    C-->>S: FIN (重传...)

    S->>C: FIN (最终要关闭时发FIN)
    Note right of S: 但没有对客户端FIN的确认
    Note left of C: 客户端仍认为自己的FIN没确认成功

```

如果省略第二个 ACK

- 如果主动关闭方不对服务端的 FIN 做确认，服务端就无法确定它的 FIN 是否到达，可能会反复重传 FIN。
- 直到超时，连接才会被强制关闭。

```mermaid
sequenceDiagram
    participant C as 客户端(主动关闭)
    participant S as 服务端(被动关闭)

    C->>S: FIN
    S->>C: ACK
    S->>C: FIN
    Note left of C: 客户端未回复ACK

    Note right of S: 服务端等待ACK超时，重传FIN
    S-->>C: FIN (重传)
    S-->>C: FIN (重传...)

```

### TCP 可靠的原因

1. 序列号和确认号（seq，ack）
2. 超时重传
3. 滑动窗口 和拥塞控制（慢启动、拥塞避免、快速重传、快速恢复）
4. 校验和

### 可能会问的问题

#### 网络层面

1. TCP/IP 网络模型的层次及前端开发中的作用

    TCP/IP 模型通常分为 **4 层**（从下到上）：

    - **网络接口层**：负责物理传输（如以太网、Wi-Fi），处理数据帧的发送和接收。
      前端体现：前端不直接操作，但网络硬件（如路由器）的稳定性会影响资源加载速度。
    - **网络层**：核心是 IP 协议，负责数据包的路由和寻址（通过 IP 地址）。
      前端体现：DNS 解析（将域名转为 IP 地址）是网络层的关键操作，前端的所有请求（如 `fetch`、图片加载）都依赖 DNS 解析结果。
    - **传输层**：包含 TCP 和 UDP 协议，负责端到端的数据传输。
      前端体现：
      - TCP 用于 HTTP/HTTPS 请求（保证数据可靠传输，如页面资源、接口数据）；
      - UDP 用于实时性要求高的场景（如 WebRTC 视频通话、WebSocket 底层有时也用 UDP）。
    - **应用层**：包含 HTTP、HTTPS、WebSocket 等协议，定义数据交互格式。
      前端体现：直接使用的协议层，如 `XMLHttpRequest`、`fetch` 基于 HTTP，`WebSocket` 协议用于实时通信，前端框架的接口请求均基于此层。

2. TCP 的三次握手与四次挥手

     三次握手（建立连接）

    **流程**：

    1. 客户端发送 `SYN` 包（请求建立连接，携带初始序列号 `seq=x`）；
    2. 服务器回复 `SYN+ACK` 包（同意连接，携带 `seq=y` 和确认号 `ack=x+1`）；
    3. 客户端回复 `ACK` 包（确认收到，携带 `ack=y+1`）。

    **设计原理**：

    - 确保双方「发送」和「接收」能力均正常（三次交互可验证双向通信）；
    - 防止「失效的连接请求」被服务器接收（若仅两次握手，客户端超时重发的旧 `SYN` 可能被服务器误认，导致资源浪费）。

     四次挥手（断开连接）

    **流程**：

    1. 客户端发送 `FIN` 包（请求关闭，`seq=u`）；
    2. 服务器回复 `ACK` 包（确认关闭请求，`ack=u+1`）；
    3. 服务器发送 `FIN` 包（服务器数据发送完毕，请求关闭，`seq=v`）；
    4. 客户端回复 `ACK` 包（确认服务器关闭，`ack=v+1`）。

    **设计原理**：

    - TCP 是「全双工」通信，双方需各自关闭发送通道（因此服务器的 `FIN` 和 `ACK` 不能合并，需分两次发送）；
    - 确保双方数据均已传输完毕（客户端最后一次 `ACK` 会等待超时，防止服务器未收到确认而重发 `FIN`）。

3. 从输入网址到网页显示的全过程

    1. **DNS 解析**：将域名（如 `www.baidu.com`）转为 IP 地址（如 `180.101.50.242`），优先查本地缓存，再查 DNS 服务器。

    2. **建立 TCP 连接**：通过三次握手与目标服务器建立可靠连接。

    3. **HTTPS 握手（若适用）**：客户端与服务器协商加密算法，交换证书，生成会话密钥（用于后续加密通信）。

    4. **发送 HTTP 请求**：客户端发送请求行（方法、路径）、请求头（`User-Agent`、`Cookie` 等）、请求体（如 POST 数据）。

    5. **服务器处理请求**：解析请求，查询数据库，生成响应（状态码、响应头、响应体）。

    6. 接收响应并渲染

       - 浏览器解析 HTML 生成 DOM 树，解析 CSS 生成 CSSOM 树，合并为渲染树；

       - 布局（计算元素位置）、绘制（像素填充）、合成（图层合并），最终显示页面。

    **涉及协议**：DNS、TCP、TLS（HTTPS）、HTTP；关键步骤核心是「寻址→连接→传输→渲染」。

 4. HTTP/1.1 与 HTTP/2 的区别及优化

    | 特性       | HTTP/1.1                   | HTTP/2                       |
    | ---------- | -------------------------- | ---------------------------- |
    | 传输方式   | 文本传输，明文可读         | 二进制分帧，不可读           |
    | 多路复用   | 无（连接数限制，队头阻塞） | 支持（单连接并行传输请求）   |
    | 头部压缩   | 无（重复头部浪费带宽）     | HPACK 算法压缩头部           |
    | 服务器推送 | 无                         | 可主动推送关联资源（如 CSS） |
    | 优先级     | 无                         | 支持请求优先级排序           |

    **HTTP/2 优化点**：

    - 解决 HTTP/1.1 的「队头阻塞」（一个请求阻塞同连接所有请求）；
    - 减少连接建立开销（单连接承载多请求）；
    - 压缩重复头部（如 `Cookie`、`User-Agent`），降低带宽消耗。

 5. HTTPS 握手过程及 RSA 加密的作用

     握手过程（简化）：

    1. 客户端发送「客户端问候」：支持的加密算法（如 RSA）、随机数 `C`。
    2. 服务器回复「服务器问候」：选择加密算法（RSA）、随机数 `S`、服务器证书（含公钥）。
    3. 客户端验证证书：确认证书有效性（通过 CA 根证书），生成「预主密钥 `P`」，用服务器公钥加密 `P` 后发送。
    4. 服务器用私钥解密 `P`，双方基于 `C+S+P` 生成「会话密钥」。
    5. 后续通信：用会话密钥（对称加密）传输数据。

    **RSA 的作用**：

    - 在握手阶段安全传输「预主密钥 `P`」（公钥加密 → 私钥解密，确保只有服务器能解密）；
    - 非对称加密（RSA）仅用于密钥交换，后续数据传输用对称加密（效率更高）。

 6. HTTP 与 WebSocket 的区别及应用场景

     核心区别：

    - **HTTP**：单向通信（客户端请求→服务器响应），无状态，连接随响应结束关闭（短连接）。
    - **WebSocket**：全双工通信（双方可主动发送数据），持久连接，连接建立后保持打开状态。

     应用场景：

    - **HTTP**：适合「请求 - 响应」模式，如页面加载、接口查询（大部分网页场景）。
    - **WebSocket**：适合实时通信，如聊天软件、股票行情更新、在线协作工具（需服务器主动推送数据）。

    **为什么需要 WebSocket**：
    HTTP 轮询（定时请求）效率低（冗余请求多），而 WebSocket 一次连接可双向通信，减少带宽和服务器压力。

 7. DNS 查询机制及前端优化

     工作机制：

    1. **本地缓存查询**：先查浏览器缓存、操作系统缓存（如 `hosts` 文件）。
    2. **递归查询**：若本地无缓存，本地 DNS 服务器（如路由器）向根域名服务器→顶级域名服务器（如 `.com`）→权威域名服务器查询，最终返回 IP。

     前端优化手段：

    - **DNS 预解析**：通过 `<link rel="dns-prefetch" href="https://cdn.example.com">` 提前解析第三方域名，减少后续请求的 DNS 耗时。
    - **减少域名数量**：合并静态资源域名（如将图片、JS 放在同一 CDN 域名），减少 DNS 查询次数。

 8. TCP 半连接队列、全连接队列与前端加载

    - **半连接队列**：存放处于 `SYN_RCVD` 状态的连接（三次握手第一步，客户端发送 `SYN` 后）。
    - **全连接队列**：存放完成三次握手（`ESTABLISHED` 状态）但未被应用层（如服务器）处理的连接。

     对前端的影响：

    - 若队列满，新连接会被丢弃，导致前端资源（如 JS、图片）加载超时、重试，延长页面加载时间。

     前端应对：

    - 减少并行请求数（避免同时发起过多连接）；
    - 使用 HTTP/2 多路复用（单连接承载多请求，减少连接建立）；
    - 合理设置缓存（减少重复请求）。

9. 跨域通信的网络协议层面思路

​	跨域的核心是浏览器的「同源策略」，以下方法利用协议特性突破限制：

	1. **CORS（跨域资源共享）**：
	   - 利用 HTTP 扩展头（如 `Access-Control-Allow-Origin`），服务器通过响应头声明允许的跨域来源，浏览器验证后放行。
	
	2. **JSONP**：
	   - 利用 `<script>` 标签不受同源限制的特性，通过动态创建 `script` 发送请求，服务器返回回调函数包裹的数据（基于 HTTP 协议）。
	
	3. **WebSocket**：
	   - 握手阶段使用 HTTP，但协议升级后（`Upgrade: websocket`）不受同源限制，基于 WebSocket 协议本身的跨域支持。
	
	4. **iframe + postMessage**：
	   - 基于 HTML5 API，但底层依赖 HTTP 连接，通过 `postMessage` 跨窗口通信，规避同源限制。


​     

10. TCP 拥塞控制及大文件上传优化

 拥塞控制机制：

TCP 通过以下算法避免网络拥塞：

1. **慢启动**：初始发送窗口小（如 1 个 MSS），每收到确认窗口翻倍（指数增长）。
2. **拥塞避免**：窗口增长到阈值后，每轮确认窗口 +1（线性增长）。
3. **快重传**：收到 3 个重复 ACK 后，立即重传丢失的包（不等待超时）。
4. **快恢复**：重传后窗口减半，进入拥塞避免阶段（而非重新慢启动）。

 大文件上传优化（基于拥塞控制）：

1. **分块上传**：将大文件拆分为小块（如 1MB / 块），类似 TCP 分段，单个块丢失不影响整体，减少重传成本。
2. **控制并发数**：限制同时上传的块数量（如 3-5 个），避免触发拥塞控制（窗口收缩）。
3. **动态调整块大小**：根据网络状况（如丢包率）调整块大小（差网络用小 block）。
4. **使用 HTTP/2 多路复用**：单连接传输多块，减少 TCP 连接建立开销，避免多连接竞争带宽导致的拥塞。
