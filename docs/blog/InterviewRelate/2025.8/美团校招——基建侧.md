# 面试问题

## 一面

1. 自我介绍
2. 介绍一下你做的 RFC，为什么要做
   1. 更新包版本之后如何保障质量，
3. 你做的平台主要功能是啥
4. 你提到微前端，有哪些微前端的实现
   1. 微前端中多技术栈的项目如何做的隔离不报错呢
5. mcp 和 function call 的区别
   1. 为什么要做这个东西
   2. 做这个东西的作用是什么
6. 你做了性能优化，你了解哪些指标是如何实现的
7. ai coding
8. 路由模式有哪些，如何实现，有什么区别
9. vue3 和 react18 的虚拟 dom 有什么区别
10. vue3 的 hook 是如何存储的
11. react18 和 vue3 的批量更新是如何做的
12. 删除链表中倒数的第 n 个节点
13. 实现`add(1)(2)(3)`

## 二面

1. 对美团基建组的看法 && 意愿
2. 你在实习过程中做的最有挑战的事是什么
   1. 提到了设计模式，讲一下你比较熟悉的设计模式
      1. 开放封闭，对拓展开放对修改封闭
      2. 里氏替换，子类可以替代父类，父类不可以替换子类
      3. 单一职责，每个类或者函数都应该只有一个职责，不要做太多的事情
3. 你做的 MCP 是什么呢
4. cicd 降低这么多是如何做到的
5. 你在字节这边使用 react 多，那么在使用 react 过程中你遇到的坑有哪些。此外 react 底层的内容你有了解过吗（讲了 fiber，渲染机制，diff 算法）
6. 浏览器渲染原理
   1. 布局树是什么
7. 跳跃游戏
8. 反问
   1. 主要是做基建侧相关的，比如 bridge
   2. ai 落地也是这边在做 比如 图生码
   3. 渲染方面也在做，魔改 blink 引擎
   4. 公司的监控也是在做

# 面试回答

1. 介绍一下你做的 RFC，为什么要做
   1. 更新包版本之后如何保障质量，
2. 你提到微前端，有哪些微前端的实现

| 方案                           | 原理                                                                                             | 优点                                   | 缺点                                                 | 适用场景                                  |
| ------------------------------ | ------------------------------------------------------------------------------------------------ | -------------------------------------- | ---------------------------------------------------- | ----------------------------------------- |
| 路由式（qiankun）              | 基于`single-spa`，通过路由匹配子应用，加载子应用 JS/CSS，管理生命周期（bootstrap/mount/unmount） | 实现简单、子应用独立部署、支持预加载   | 页面切换有加载开销、不支持同页多子应用               | 中后台系统（如 ERP、OA）                  |
| Web Components 式（micro-app） | 子应用封装为 Web Components，主应用通过自定义标签引入，用 Shadow DOM 实现样式隔离                | 组件化集成、支持同页多子应用、原生隔离 | 子应用需适配 Web Components、兼容性有限（IE 不支持） | 需嵌入多子应用的页面（如首页）            |
| iframe 式                      | 通过 iframe 嵌套子应用，天然实现 JS / 样式隔离                                                   | 隔离性最好、子应用无需改造             | 通信复杂（postMessage）、性能开销大（资源重复加载）  | 需强隔离的场景（如第三方系统嵌入）        |
| 模块联邦（Webpack5）           | 不同应用共享模块，主应用动态加载子应用模块，子应用也可加载主应用模块                             | 模块级共享、减少重复加载、集成灵活     | 依赖 Webpack 生态、配置复杂                          | 技术栈统一（如均为 React/Vue3）的大型应用 |

- 微前端中多技术栈的项目如何做的隔离不报错呢？——主要是三层隔离
  1. js 隔离（沙箱，为每个子应用创建一个独立的运行时环境）
  2. 样式隔离，css module or shadow DOM

3. mcp 和 function call 的区别 4. mcp 是开放协议，让模型作为 mcp client 去请求 mcp server，mcp server 中存在很多工具，通过这些工具去操作是对应的内容，类似于跨端？一个编译多次复用
   而 function call 是私有化协议，每个模型都有自己的 function calling 协议，不同模型完成同一项内容，需要编写不同的 function calling（**没有统一标准就是最大的问题**）

   1. 协议层面来看 无关系
      - Function Calling：是大型语言模型（LLM）内部的机制，用于将自然语言请求转换为结构化的函数调用指令。
      - MCP（Model Context Protocol）：是一个开放标准，定义了 AI 应用程序与外部工具和数据源之间的通信协议。
   2. 集成角度 mcp 是 function calling 的封装 相当于标准化了 function calling
      - Function Calling：负责将用户的自然语言请求转换为结构化的函数调用指令。
      - MCP：在接收到这些指令后，负责与外部工具和数据源进行通信，执行相应的操作，并将结果返回给 LLM。

4. 你做了性能优化，你了解哪些指标是如何实现的
5. FCP：首次内容渲染
   1. FP
   2. FMP
   3. LCP
   4. CLS
6. ai coding
7. 路由模式有哪些，如何实现，有什么区别

   1. hash 模式
      - 原理：基于 URL 的哈希值（#后内容），哈希变化不触发页面刷新，仅触发 window.hashchange 事件；
      - 优缺点
        优点：兼容性好（支持 IE）、无需后端配置；
        缺点：URL 带#不美观、SEO 友好性差（早期搜索引擎不识别哈希）。
   2. history 模式
      - 原理：基于 HTML5 的 History API（pushState/replaceState），可在不刷新页面的情况下修改 URL 和历史记录；
      - 优缺点
        优点：URL 美观（无#）、SEO 友好；
        缺点：兼容性差（不支持 IE10 及以下）、需后端配合（需将所有路由（如/home/about）指向 SPA 入口 index.html，否则刷新页面返回 404）。
   3. memory 模式
      - 原理：路由状态存储在内存（如 JS 变量），不依赖 URL；
      - 适用场景：Electron、React Native 等非浏览器环境；
      - 缺点：无法通过 URL 分享状态、刷新页面丢失路由。

8. vue3 和 react18 的虚拟 dom 有什么区别

| 维度         | Vue3                                                                                                   | React18                                                                                             |
| ------------ | ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------- |
| 结构表示     | VNode 对象（含`type`/`props`/`children`/`shapeFlag`），`shapeFlag`标记节点类型（如 ELEMENT/COMPONENT） | FiberNode 链表（含`tag`/`lane`/`sibling`/`return`），`lane`标记优先级，链表支持中断渲染             |
| 构建优化     | 编译时优化：template 编译为带静态标记的 render 函数，静态节点（无动态绑定）复用，不重新创建 VNode      | 运行时优化：Fiber 架构支持并发渲染，render 阶段可中断（处理高优先级任务后恢复）                     |
| Diff 算法    | 1. 静态节点跳过 Diff；2. 按`shapeFlag`快速判断节点类型；3. 列表 Diff 用 “最长递增子序列” 减少 DOM 移动 | 1. 深度优先 + 优先级驱动的 Diff；2. 列表 Diff 依赖`key`匹配，不直接用最长递增子序列；3. 可中断 Diff |
| 与响应式结合 | 响应式数据变化 → 触发 effect→ 执行 render 生成 VNode→Diff 更新，精准定位更新组件                       | 状态更新（setState）→ 创建更新任务 → 调度器按`lane`优先级执行 →Fiber Diff→DOM 更新                  |
| 核心优化点   | 编译时静态优化（减少 VNode 创建 / Diff）                                                               | 运行时并发调度（提升交互响应速度）                                                                  |

10. vue3 的 hook 是如何存储的
    - Vue3 的 Hook（如 ref/computed、自定义 Hook）依赖组件实例上下文存储，核心是 setupState：
      - 每个组件实例（ComponentInstance）有一个 ComponentContext，包含 setupState（存储 Hook 状态）、attrs/emit 等。
        执行 setup 函数时，Vue3 将当前实例挂载到全局 currentInstance，确保 Hook 能访问上下文。
        Vue 他的 hook 是存在当前组件实例中，Vue 的虚拟 DOM 只负责渲染为真实 DOM
      - 方便职责分类和编译优化 **虚拟 DOM 和 组件实例双向引用**
      - VNode 的 component 指向组件实例，组件实例的 vnode 指向 VNode，方便更新时 “找到对应的渲染描述” 和 “找到对应的状态容器”。
    - 而 React 的虚拟 DOM 承担了虚拟 DOM + 实例的内容
      - 强耦合（Fiber 既是 DOM 描述，也是状态载体）
      - 支持「可中断的优先级调度」（需状态与 DOM 描述绑定）
11. react18 和 vue3 的批量更新是如何做的
12. vue 的批量更新是 更新函数去重，对于变化的响应式数据是存在 effect 的，多次更新最终都是一个 effect，通过查找 effect 是否在更新任务队列中，如果在就不继续添加这样子实现批量更新
13. react 的批量更新是基于优先级的，状态更新会创建更新任务，然后 scheduler 根据任务的优先级加入队列，同一次事件循环内合并相同优先级任务。
14. 删除链表中倒数的第 n 个节点
15. 实现`add(1)(2)(3)`
