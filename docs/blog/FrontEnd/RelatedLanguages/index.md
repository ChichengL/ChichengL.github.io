[JS 八股](https://www.yuque.com/cuggz/interview/famxgp)



## JS八股

### JS引擎的执行顺序

1. **词法分析（Tokenization）**
   把 raw 代码字符串拆成最小语法单元（Token），比如 `let a = 1 + 2;` 会拆成 `let`、`a`、`=`、`1`、`+`、`2`、`;`，相当于给代码 “拆字”，过滤空格、注释等无关内容，确保后续能识别语法。
2. **语法分析（AST 生成）**
   根据 Token 序列生成「抽象语法树（AST）」—— 用树形结构表示代码的语法逻辑（比如变量声明、表达式运算的层级关系）。
   例：`a = 1 + 2` 的 AST 会有一个 “赋值节点”，左子节点是 “变量 a”，右子节点是 “加法节点”（子节点为 1 和 2）。
   *注：若语法错误（如少写分号、括号不匹配），会在此阶段报错，终止执行。*
3. **预编译（预处理）**
   基于 AST 做 “提前准备”，核心是**作用域初始化**和**变量 / 函数提升**，为后续执行铺路：
   - 创建当前作用域（全局作用域 / 函数作用域 / 块级作用域），记录变量、函数的声明信息；
   - 变量提升：将 `var` 声明的变量、`function` 声明的函数提前到作用域顶部（但赋值不提升，比如 `var a = 3` 会拆成 `var a;` 提升，`a=3` 留在原地）；
   - 块级作用域处理：对 `let/const`，会标记为 “未初始化”（TDZ 暂存死区），避免提前访问。
4. **字节码生成**
   V8 不会直接将 AST 编译成机器码（早期引擎如 SpiderMonkey 曾这么做，但启动慢、内存占用高），而是先转成「字节码」—— 一种介于 AST 和机器码之间的中间代码，体积小、生成快。
   例：`1 + 2` 会被转成类似 `Add 1, 2` 的字节码指令，供后续执行器解析。
5. **执行阶段（字节码解释 + 热点编译）**
   由「解释器（Ignition）」逐行执行字节码，同时「监视器（Monitor）」会跟踪代码执行频率：
   - 若某段代码执行次数少（冷代码），直接用解释器执行，保证启动速度；
   - 若某段代码频繁执行（热点代码，如循环、频繁调用的函数），会触发「即时编译器（TurboFan）」将其编译成**机器码**并缓存，后续执行直接用机器码（速度比字节码快 10-100 倍）。
6. **执行中的辅助逻辑**
   - 调用栈：管理函数执行顺序（先进后出，每调用一个函数就压入一个 “栈帧”，记录函数参数、局部变量、返回地址）；
   - 作用域链：查找变量时，从当前作用域向上遍历父作用域，直到全局作用域；
   - 垃圾回收（GC）：执行过程中，若局部变量出栈（函数执行完）、引用断开，GC 会标记并回收这些 “无用内存”，避免内存泄漏。



### V8 为什么快？

 1. 即时编译（JIT）：解释执行 + 编译执行的 “最优解”
    这是 V8 速度的核心，解决了传统引擎的痛点：

    - 纯解释执行（如早期 JS 引擎）：启动快，但每行代码都要实时解析，执行慢；
    
    - 纯编译执行（如 C++）：执行快，但需先把所有代码编译成机器码，启动慢、内存占用高；
    
      V8 的 JIT 逻辑：
    
      1. 首次执行代码：用「解释器（Ignition）」快速生成字节码并执行，保证启动快；
      2. 监控热点代码：「监视器」统计代码执行次数，若某段代码执行超过阈值（如循环 100 次），标记为 “热点”；
      3. 编译热点代码：「编译器（TurboFan）」后台将热点字节码编译成机器码，缓存到内存；
      4. 后续执行：直接调用缓存的机器码，跳过字节码解释步骤，执行效率大幅提升。


 2. 内联缓存（IC）：减少 “类型检查” 的重复开销
    JS 是动态类型语言（变量类型可随时变，如 `a = 1` 后可改成 `a = "hello"`），每次执行函数 / 运算时，引擎都要检查变量类型（比如 `a + b`，要判断是数字相加还是字符串拼接），这会产生大量重复开销。

    V8 的 IC 优化：

    - 对频繁调用的函数（如 `function add(a, b) { return a + b }`），记录每次传入的参数类型（如第一次是 `(Number, Number)`）；

    - 后续调用时，先检查参数类型是否和历史一致：若一致，直接用缓存的 “类型处理逻辑”（如数字加法），跳过类型重新判断；若不一致（类型突变），再触发 “去优化”，重新处理类型。
      *例：若 `add` 函数反复传入数字，IC 会缓存 “数字加法” 逻辑，执行速度接近静态类型语言。*


  3. 分代垃圾回收（GC）：减少内存回收的 “停顿时间”
     JS 开发者不用手动释放内存，但 GC 执行时若 “全量扫描内存”，会阻塞 JS 执行（导致页面卡顿）。V8 基于 “大多数对象存活时间短” 的规律，将内存分为两代，用不同策略回收：

| 内存分区 | 存储对象                     | 回收策略                  | 优点                     |
| -------- | ---------------------------- | ------------------------- | ------------------------ |
| 新生代   | 新创建的小对象（如局部变量） | Scavenge 算法（复制回收） | 速度快，单次回收耗时短   |
| 老生代   | 存活久的大对象（如全局变量） | 标记 - 清除 + 标记 - 整理 | 减少内存碎片，适合大对象 |

- 新生代回收：将内存分成 “From” 和 “To” 两个区域，新对象存在 From 区；回收时，把存活对象复制到 To 区，然后清空 From 区，再交换两者角色（下次回收从新的 From 区开始），整个过程耗时极短（毫秒级）。
- 老生代回收：采用 “增量标记 - 清除”—— 不一次性扫描所有对象，而是分多次（每次 JS 执行间隙）标记存活对象，最后统一清除无用对象；后续用 “标记 - 整理” 压缩内存，减少碎片。
  *这种分代策略让 V8 的 GC 停顿时间极短（通常 < 10ms），几乎不影响前端交互流畅性。*

 4. 字节码优化：减少 “冗余操作”
    V8 的解释器（Ignition）在生成字节码时，会做一层 “轻量级优化”，删除冗余逻辑：

    - 死代码消除：比如 `if (false) { 执行逻辑 }`，会直接删除 `if` 内部的字节码；

    - 常量折叠：比如 `let a = 1 + 2`，会直接计算成 `let a = 3`，减少执行时的加法运算；

    - 窥孔优化：比如连续的 `var a; var b;` 会合并成一个声明指令，减少字节码数量。


 5. 内存管理优化：避免 “内存碎片”
    除了 GC 优化，V8 还对内存分配做了精细控制：

    - 小对象分配：用 “内存池”（预先申请一块连续内存），小对象直接从内存池分配，避免频繁向操作系统申请内存（减少系统调用开销）；

    - 大对象分配：直接向操作系统申请 “大页内存”，且单独管理，避免和小对象混在一起导致碎片；

    - 内存对齐：按照 CPU 缓存的 “缓存行” 大小（通常 64KB）对齐内存，提升 CPU 缓存命中率（后续执行时，CPU 能更快读取内存数据）。


 6. 懒编译：延迟编译 “未执行的代码”
    V8 不会一次性编译所有代码，而是 “按需编译”：

    - 函数声明：只在函数被第一次调用时，才生成字节码并执行（若函数从未调用，就不编译，节省内存和启动时间）；

    - 模块代码：ES Module 中，未导入的模块不会提前编译，只有当 `import` 时才触发编译。
      *这种懒编译策略让 V8 启动速度更快，尤其适合大型前端项目（代码量虽大，但初始执行的代码少）。*
